<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ssh on Goldstine研究所</title>
    <link>https://blog.mosuke.tech/categories/ssh/</link>
    <description>Recent content in Ssh on Goldstine研究所</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 01 Dec 2015 18:13:00 +0900</lastBuildDate>
    
	<atom:link href="https://blog.mosuke.tech/categories/ssh/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ansible、実行速度高速化の実験。ControlMasterとPipeliningについて</title>
      <link>https://blog.mosuke.tech/entry/2015/12/01/181304/</link>
      <pubDate>Tue, 01 Dec 2015 18:13:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/12/01/181304/</guid>
      <description>1. はじめに
Vim::Factoryの開発や、仕事などでAnsibleを使うことが多いのだが、
その実行速度があまりでないことに不満をもっていて、どうしたら早くできるか考えていました。
調べると、ControlMasterを利用してSSHのコネクションを再利用するとか、pipelineの機能を利用するとかでてくる。
が、それによってどのくらいの効果が得られるのかよくわからないし、仕組みもよくわかっていなかったので、仕組みの理解と実行速度の実験をした。
もう少し余談をすると、
ControlMasterを有効にすれば早くなることは前から知っていたが、
最近MacをEl Capitanに変えてから「なんか最近Ansibleはやいな〜」とか思っていて、
「OpenSSHのバージョンもあがったし、まさか。。。」と思って今にいきついている。
ControlMasterについて OpenSSH は、1 つの接続で複数のセッションを共有する(束ねる)「コントロール マスター」と呼ばれる機能を持っています。コントロールマスターを使用すると、 リモートホストに接続する最初のセッションは制御用のセッション(マスターセッショ ンと呼ばれます)として利用され、制御用のソケットを作成します。セッションを 共有する SSH クライアントは、この制御用のソケットを通じてリモートホストと 接続し通信を行います。
出典：「OpenSSH実践入門」
 上記のように、１つの接続で複数のセッションを共有するため、
Ansibleのようにタスク実行ごとにSSH接続するような場合には大きな効果を得ることができる。
Pipeliningについて Pipelining機能の説明の前に、軽くAnsibleの実行までの流れを説明する。
Ansibleは対象サーバにSSHログインしたあと実行するタスクのモジュールをファイルとして転送しそれを実行する。
Pipelining機能をなしの状態だと、このファイル転送とファイルの削除を１タスクごとに行う。
ansibleを-vvvvオプションをつけて実行するとわかるが、
４行目でファイルのPUT（転送）を、５行目の最後の方にrm -rfでディレクトリ・ファイルの削除を行っている。
&amp;lt;192.168.33.100&amp;gt; ESTABLISH CONNECTION FOR USER: deploy &amp;lt;192.168.33.100&amp;gt; REMOTE_MODULE command ls -l /root &amp;lt;192.168.33.100&amp;gt; EXEC ssh -C -tt -vvv -o ControlMaster=auto -o ControlPersist=300s -o ControlPath=&amp;quot;/Users/xxxxx/.ansible/cp/ansible-ssh-%h-%p-%r&amp;quot; -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o User=user -o ConnectTimeout=10 192.168.33.100 /bin/sh -c &#39;mkdir -p $HOME/.</description>
    </item>
    
    <item>
      <title>Ansibleを踏み台サーバ越しに実行する</title>
      <link>https://blog.mosuke.tech/entry/2015/09/25/232751/</link>
      <pubDate>Fri, 25 Sep 2015 23:27:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/09/25/232751/</guid>
      <description>タイトルの通りで、なにも特別なことはない内容。
そして、9月も終わりなのに今月はひとつも記事を書いていなかった。
KVMを使って仮想のゲストサーバを立てたが、
ゲストサーバはホストサーバと通信する用の（外に出る場合にはNAT通信で）IPアドレスしか持っていない状況で、
Ansibleの実行対象としたかったのが背景。
ホストサーバにAnsibleをいれるわけにもいかず、ホストサーバを踏み台にして、
Ansibleを打ちたかったというもの。

 SSHの設定ファイルを作る &#34;Ansibleで&#34; と書いたが要はSSHです。
まずはSSHで踏み台サーバを経由してAnsible実行対象サーバへ接続できるように準備しました。
これはいわゆる「多段SSH」というやつで、以前にもブログに書いたので復習です。
【VPS1台でインフラ勉強】多段SSH設定（おまけ） - Goldstine研究所
一般的には~/.ssh/configにこういった設定は書いたりもしますが、
Ansible実行の場合、端末に依存したくなかったので、
Ansibleレポジトリに別途ファイルを作ることにした。
## sshconfigという名前のファイルにした Host ansible-target HostName 192.168.33.10 User xxxxx ProxyCommand ssh -W %h:%p yyyyy@hostserver  上記のファイルを使って多段SSHできることを確認します。
$ ssh -F sshconfig ansible-target  Ansible実行時にSSH設定ファイルを利用する ここまで来たらとても簡単で、
ansible.cfgに下記を追記し、ansible実行時に上記のsshconfigを読み込まれるようにしました。
ansible.cfg
[ssh_connection] ssh_args = -F sshconfig</description>
    </item>
    
    <item>
      <title>デスクトップUbuntuにVNC接続。ついでにSSHローカルポートフォワードの復習。</title>
      <link>https://blog.mosuke.tech/entry/2015/08/13/000440/</link>
      <pubDate>Thu, 13 Aug 2015 00:04:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/08/13/000440/</guid>
      <description>完全に自分のための備忘録。内容はわりと薄め。
やったこと 最近、自作したPCにUbuntuをいれて使っているのだけど、
デスクトップPCなので、部屋でしか操作することができません。
他の部屋からノートPCでUbuntuを触れたらいいなーと思いその環境を整えることをしました。
主にやったことは以下の通りです。
  VNCサーバ構築について ノートPC（Mac）からのVNC接続について  SSHローカルポートフォワードを使ってのセキュアな接続について   UbuntuでのVNCサーバ構築について 今回利用しているUbuntuは「Ubuntu Desktop 14.04」です。
また、VNCの実現は標準でインストールされているvinoを使って行いました。
ご存知の方も多くいるかもしれませんが、vinoでのVNCは簡易的なもので、サーバ側のユーザがログアウトしていると使えません。
ですので、会社などでの利用には耐えないと思います。
ユーザーをログアウトせずにロック状態にしていれば使えます。
まずはデスクトップ共有の設定をします。
「デスクトップの共有」のアプリケーションを起動します。 
接続毎に要求するようにすると、サーバ側で毎度許可が必要なので、オフにします。
パスワードの設定はしておきましょう。
同じLANをつかんでる人に簡単に奪われてしまいますので。

ちょっと詳細な意味を把握していないのですが、
下記を実行しないとMacで接続すると「互換性のないバージョンです」的なこといわれました…すいません。
$ gsettings set org.gnome.Vino require-encryption false  設定ができたら、きちんとサーバとしてVNC接続を待ち受けているか確認します。
% sudo lsof -i:5900 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME vino-serv 24414 mosuke5 13u IPv6 156661 0t0 TCP *:5900 (LISTEN) vino-serv 24414 mosuke5 14u IPv4 156662 0t0 TCP *:5900 (LISTEN) % ps -ef | grep vino mosuke5 24414 24226 0 12:30 ?</description>
    </item>
    
    <item>
      <title>SSHエージェントフォワード後に他のユーザでgit cloneする(鍵を使う)ことに関する考察</title>
      <link>https://blog.mosuke.tech/entry/2015/04/05/212518/</link>
      <pubDate>Sun, 05 Apr 2015 21:25:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/04/05/212518/</guid>
      <description>SSHのエージェントフォワードした後に、接続したユーザとは別のユーザでgit cloneしたいことがあった。
それについて調べていく中で学習したことや検討したことについてまとめた。
0. 前提 ローカルのPC(Mac)上で、Vagrantを使用してCentOS7の仮想サーバ(testsv)を立ち上げている。
&amp;lt;IPアドレス&amp;gt;
ローカルPC：192.168.33.1
仮想サーバ：192.168.33.100
本記事上での「git cloneする」とは、「プライベートのGitレポジトリからSSHを利用してクローンする」ということを指す。
1. SSHのエージェントフォワードを利用したい理由 まず、そもそもなぜSSHのエージェントフォワードをする必要があったのか。
最近では多くの方がご存知かつ利用していることだと思うが、仮想のサーバ上でgitを利用するときによく利用する。
(もちろんそれだけの用途ではありません)
仮想サーバを作るたびにSSHの鍵を生成して、Github等に登録するのが手間なので、
ローカルのPCの鍵を他のサーバへ引き継ぐことでgit clone等を可能にするのだ。
2. SSHエージェントフォワード利用時の挙動 SSHのエージェントフォワードで利用される認証情報は、接続先サーバの/tmp以下に保存されます。
[myuser@localpc ~]$ ssh -A vagrant@192.168.33.100 Last login: Sat Apr 4 xx:xx:xx 2015 from 192.168.33.1 [vagrant@testsv ~]$ [vagrant@testsv ~]$ ls -l /tmp | grep ssh drwx------. 2 vagrant vagrant 23 4月 4 11:35 ssh-skQVHsUCHU  
また、接続ユーザにはSSH_AUTH_SOCKという環境変数ができ、どの認証情報を利用するか記述がされます。
実際に確認してみる。
確認方法は、envコマンドで環境変数一覧を表示し、そのなかで&#34;ssh&#34;を含むものをgrep。
[vagrant@testsv ~]$ env | grep -i ssh SSH_AUTH_SOCK=/tmp/ssh-skQVHsUCHU/agent.9034 SSH_CLIENT=&#39;192.168.33.1 58017 22&#39; SSH_CONNECTION=&#39;192.</description>
    </item>
    
    <item>
      <title>SSHポートフォワード、https接続をするときに間違えやすいこと</title>
      <link>https://blog.mosuke.tech/entry/2015/02/11/172123/</link>
      <pubDate>Wed, 11 Feb 2015 17:21:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/02/11/172123/</guid>
      <description>SSHローカルフォワードの話。
前回は簡単に実践してみたというのを書いたのだが、今度は実際に使ってみてハマった部分があったのでメモ。
SSHでローカルポートフォワードを実際に試す - Goldstine研究所
1. やりたいこと httpsでしか接続を許可していないサーバへ、SSHローカルフォワーディングを使って接続しようした。
（直接疎通性がないためにポートフォワーディングする必要があった。）
2. 行ったこと httpsでしか接続ができないので、ローカル端末のポート5000を接続したいサーバのポート443に飛ばせばおっけーと思って、
下記のようにssh接続とブラウザから接続を行った。
ssh -L5000:web-host:443 user@ssh-host  ※web-host: 今回httpsで接続したサーバ
※ssh-host: ssh接続先サーバ
これでローカルフォワーディングの設定は終わったので、ブラウザから以下に接続するだけで終わりだと思っていた。
http://localhost:5000  が、接続不可…なぜでしょう？
3. 何が間違いだったか 正しくは以下で接続をしなければいけない。httpsが必要。
https://localhost:5000  よーく考えればアタリマエのこと。
URLのはじめの&amp;lt;http(s)&amp;gt;の部分はプロトコルで最後の&amp;lt;:5000&amp;gt;の部分はポート番号。
httpsは443のポートを一般的に使うが、ポート443がhttpsというわけではない。
あたりまえのことだし知っていることなんだけど、見落としがちかもしれない。</description>
    </item>
    
    <item>
      <title>SSHでローカルポートフォワードを実際に試す</title>
      <link>https://blog.mosuke.tech/entry/2014/12/31/170545/</link>
      <pubDate>Wed, 31 Dec 2014 17:05:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2014/12/31/170545/</guid>
      <description>SSH・・・
いろんなことができる&amp;rdquo;らしい&amp;rdquo;ということは知っていたし、
例えばポートフォワーディングなんていうこともできるのも知っている。
でもそれがどんなものなのか自分の手で試したことはないし、
なんとなくただのサーバログインツールとして利用していた。
サーバインフラ技術に興味を持つようになっていろんなことを勉強していると、
ポートフォワーディングは必須な技術であることも感じ、
年末の持て余す時間を使ってSSHのローカルポートフォワードを試してみたのでメモする。
環境とやりたいこと 
ローカルPCからexample.jpは以下で接続できる状態。
[local pc] $ ssh username@example.jp  またWebサーバのポート番号は80で、VPSのホストサーバからはWebサーバへ接続できる。
CUIなのでわかりづらいがcurlを打つとHello Worldが返ってきている。
[example.jp] $ curl 192.168.33.10 &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello World! Virtual Web Server&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;  ローカルポートフォワードの実行 ローカルPCから以下を実行する。
以下のコマンドは、
ローカルPCのポート8888での接続はexample.jpからみて「192.168.33.10のポート80」に飛ばす
といったもの。
[local pc] $ ssh -L8888:192.168.33.10:80 username@example.jp  この状態でブラウザからhttp://localhost:8888にアクセスすると
なんと、ローカルホストにつないだはずが、example.jp上の仮想Webサーバのhtmlがうつっているではないか…

セキュリティはどうなの？ ローカルの端末からhttpで仮想のWebサーバに接続しているけど、セキュリティはだいじょうぶなのだろうか？
http通信だから暗号化はされていないのだろうか？
なんて疑問もあるが、それは問題ない。
SSHでローカルPCからリモートホスト(example.jp)までトンネルをはり、
そのなかをhttpで通信しているから全く問題なしといえる。
ローカルポートフォワードを利用する場合は、おそらく表には出したくないけど、
ローカルから接続したいなどの要件の時に使うと思うけど、SSHできちんと暗号化しているので安心。
最後に SSHでできることはこの他にもたくさんある。
ポートフォワードだけみても他にも「リモートポートフォワード」や「ダイナミックポートフォワード」などがある。
リモートポートなどはいまぱっと試せる環境がなかったのでおいおい実践してみる…
SSHをただのログインツールだけに留めるのは今年で終わりにしよう…</description>
    </item>
    
    <item>
      <title>【VPS1台でインフラ勉強】多段SSH設定（おまけ）</title>
      <link>https://blog.mosuke.tech/entry/2014/11/09/172745/</link>
      <pubDate>Sun, 09 Nov 2014 17:27:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2014/11/09/172745/</guid>
      <description>VPS1台でインフラ勉強の会で、VPSのホストサーバ上に仮想でさらにいつくかのサーバを立てたが、
仮想のサーバにアクセスするには、ホストサーバにアクセスしてから更にSSHをしなければならない。
これが面倒だったので多段SSHの設定をして、一発でSSH接続できるようにした。
以下の図で言うと、web10, web11(192.168.33.10&amp;frasl;11)に一発でSSHできるようにする。

クライアントPC側に以下の設定をした。
$ vim ~/.ssh/config host gateway HostName xxxxx.xxx User username Host web10 HostName 192.168.33.10 User vagrant ProxyCommand ssh -W %h:%p gateway Host web11 HostName 192.168.33.11 User vagrant ProxyCommand ssh -W %h:%p gateway ##これで以下で接続可能 $ ssh web10 $ ssh web11  簡単でした。</description>
    </item>
    
  </channel>
</rss>