<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ansible on Goldstine研究所</title>
    <link>https://blog.mosuke.tech/categories/ansible/</link>
    <description>Recent content in Ansible on Goldstine研究所</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Mon, 25 Jan 2016 22:21:00 +0900</lastBuildDate>
    
	<atom:link href="https://blog.mosuke.tech/categories/ansible/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vagrant×Ansible環境の３つのスタイルとそのメリット・デメリットについて</title>
      <link>https://blog.mosuke.tech/entry/2016/01/25/222150/</link>
      <pubDate>Mon, 25 Jan 2016 22:21:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2016/01/25/222150/</guid>
      <description>Vagrant×Ansibleで開発環境を作っているみなさんは、 どんなふうにそれを実現していますか？
きっといくつかのやり方、考え方があると思います。
例えば、ご自身のPCにAnsibleをインストールしてVagrantの仮想環境にプロビジョニングしているとか。
Vagrantで立てた仮想環境にAnsibleを入れて実行するとか。
本ブログでは下記３つのVagrant×Ansibleのやり方に注目し、
そのメリット・デメリットについて自分なりにまとめます。
 ホストにAnsibleをインストールして利用する ゲストにAnsibleをインストールして利用する Ansible実行用のゲストを作って利用する  1. ホストにAnsibleをインストールして利用する 概要 1番よくあるやり方だと思う。
ご自身のPCにAnsibleを入れてVagrantで立ち上げたゲストにプロビジョニングを行う。

メリット なんといっても直感的でシンプル。
3.との比較になるが、Ansibleを実行する環境を別途用意する必要がないのでホストのリソースにも優しい。
また、2.との比較でゲストに無駄なものが入らない点でよい。
デメリット ただ、そもそもwimdowsユーザはホストにAnsibleをインストールすることはできない。
つまり、複数人での開発をしていて、人によって端末が異なる場合には向いていない。
個人の端末の設定などにも大きく依存するため、チーム開発向きでないといえる。
2. ゲストにAnsibleをインストールして利用する 概要 Vagrantで立ち上げたゲストの中にAnsibleをインストールし、自身へプロビジョニングするやりかた。

この方式はshin1x1さんもおすすめしている。
Vagrant + Ansible で開発環境を作るなら ansible_local プロビジョナがいい！ - Shin x Hatena Blog メリット （詳しくは上のブログを読むといいと思う。）
1.のデメリットで述べた、端末への依存度をなくすことができる。
vagrantの新機能であるansible_localも利用できるのでプロビジョニングが楽だ。
3.と比べてAnsible実行環境を用意しなくて済む。
デメリット メリットだけみると1.の問題点を解決していて最高のようにみえる。
しかし、ゲストに本来インストールされるべきものでないものがはいる点は忘れてはいけない。
Ansibleを使ってプロダクション環境にデプロイするユーザにとっては大きな問題だと思う。
開発環境とプロダクション環境での差分が広がってしまう。
また、Ansibleと並行してserverspecを使ってる人も多いと思うが、
そうなると今度はゲスト側にRubyもいれるのか？など様々な疑問が湧いてくる。
3. Ansible実行用のゲストを作って利用する 概要 Ansible実行用のゲストをVagrantで立ち上げて、開発用のゲストへプロビジョニングにする。 
メリット 2.のデメリットで述べた、ゲストへの不要なもののインストールを防ぐことが可能。
例えばserverspecでRubyが必要な場合もAnsible実行用のゲストに入れればいい。
必要なものをインストールしたAnsible実行用のイメージファイルをチーム内で共有すれば端末依存もセットアップの手間も省ける。
デメリット なんといっても、ゲストを二つは立ちあげる必要があること。
これは少し面倒だ。
まとめ</description>
    </item>
    
    <item>
      <title>インフラのデプロイとテストを同時実行できるようにしてHappyになった</title>
      <link>https://blog.mosuke.tech/entry/2015/12/17/192554/</link>
      <pubDate>Thu, 17 Dec 2015 19:25:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/12/17/192554/</guid>
      <description>はじめに
私が開発しているシステムでは、Ansibleでサーバ構築からアプリケーションのデプロイまですべて実行できるようにしています。 そして、serverspecを使って、インフラテストも行っています。
しかし、その運用にいくつか課題点がありました。
その課題点についてと、課題点へ対策したことについて書きます。
課題だったこと (課題1) デプロイとテストをそれぞれ実行していた Ansibleでのデプロイとserverspecのテストはそれぞれ別のコマンドで実行していました。
$ ansible-playbook site.yml -i $ bundle exec rake serverspec  2つ実行することが面倒であり、面倒であるがゆえにserverspecの実行を怠ったりしていました。
これではテストの効果があまり発揮できませんね。
(課題2) sudoパスワードをうまく管理できなかった 上のような課題1について、真っ先に以下の様にコマンドを続けることを思いつきました。
$ ansible -playbook site.yml -i ; bundle exec rake serverspec  ですが、これだとansible実行終了後にserverspecを実行する際にsudoパスワードが再度聞かれるため、
コマンドを打ったまま「放置」ができませんでした。
※もちろん、sudoパスワードを要求しないようにユーザ設定をすればできますが、多くの場合ではセキュリティ上難しかったりすると思います。ssh接続は鍵認証、sudoには必ずパスワードを要求するようにしています。
Ansibleもserverspecにもコマンド実行時にsudoパスワードを記述する方法があります。
Ansibleでは、ansible.cfgにsudo_passwordを記述、あるいはコマンド実行時に--extra-argsでsudoパスワードを指定できます。
serverspecでも環境変数でSUDO_PASSWORDが指定できます。
例 ）
ansible -playbook site.yml -i --extra-args=&#39;ansible_sudo_pass=xxxxxxxx&#39; bundle exec rake serverspec SUDO_PASSWORD=xxxxxxxx  ですが、おわかりの通り、コマンドの履歴にもパスワードが残ります。
なのであまり良い方法ではないと思っています。
(課題3) タスクの実行方法がバラバラ デプロイはansibleコマンドで実行、テストはrakeで実行、他のタスクはシェルスクリプト。。。
といったように、タスクによって実行方法が異なってしまう状況になっていました。
運用的にとても不便でしたので、１つに統一したいと思っていました。
いい感じに同時に実行してくれるRakeタスクを作った 上で述べたような課題点をクリアするように、下記の要件を満たすように工夫をしました。
 デプロイ、テストが同じ形式で実行できる sudoパスワードをベタ書きすることなく実行できる sudoパスワードの入力を一回だけにする  結論は、すべてRakeタスクで実行できるようにしました。</description>
    </item>
    
    <item>
      <title>Ansible、実行速度高速化の実験。ControlMasterとPipeliningについて</title>
      <link>https://blog.mosuke.tech/entry/2015/12/01/181304/</link>
      <pubDate>Tue, 01 Dec 2015 18:13:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/12/01/181304/</guid>
      <description>1. はじめに
Vim::Factoryの開発や、仕事などでAnsibleを使うことが多いのだが、
その実行速度があまりでないことに不満をもっていて、どうしたら早くできるか考えていました。
調べると、ControlMasterを利用してSSHのコネクションを再利用するとか、pipelineの機能を利用するとかでてくる。
が、それによってどのくらいの効果が得られるのかよくわからないし、仕組みもよくわかっていなかったので、仕組みの理解と実行速度の実験をした。
もう少し余談をすると、
ControlMasterを有効にすれば早くなることは前から知っていたが、
最近MacをEl Capitanに変えてから「なんか最近Ansibleはやいな〜」とか思っていて、
「OpenSSHのバージョンもあがったし、まさか。。。」と思って今にいきついている。
ControlMasterについて OpenSSH は、1 つの接続で複数のセッションを共有する(束ねる)「コントロール マスター」と呼ばれる機能を持っています。コントロールマスターを使用すると、 リモートホストに接続する最初のセッションは制御用のセッション(マスターセッショ ンと呼ばれます)として利用され、制御用のソケットを作成します。セッションを 共有する SSH クライアントは、この制御用のソケットを通じてリモートホストと 接続し通信を行います。
出典：「OpenSSH実践入門」
 上記のように、１つの接続で複数のセッションを共有するため、
Ansibleのようにタスク実行ごとにSSH接続するような場合には大きな効果を得ることができる。
Pipeliningについて Pipelining機能の説明の前に、軽くAnsibleの実行までの流れを説明する。
Ansibleは対象サーバにSSHログインしたあと実行するタスクのモジュールをファイルとして転送しそれを実行する。
Pipelining機能をなしの状態だと、このファイル転送とファイルの削除を１タスクごとに行う。
ansibleを-vvvvオプションをつけて実行するとわかるが、
４行目でファイルのPUT（転送）を、５行目の最後の方にrm -rfでディレクトリ・ファイルの削除を行っている。
&amp;lt;192.168.33.100&amp;gt; ESTABLISH CONNECTION FOR USER: deploy &amp;lt;192.168.33.100&amp;gt; REMOTE_MODULE command ls -l /root &amp;lt;192.168.33.100&amp;gt; EXEC ssh -C -tt -vvv -o ControlMaster=auto -o ControlPersist=300s -o ControlPath=&amp;quot;/Users/xxxxx/.ansible/cp/ansible-ssh-%h-%p-%r&amp;quot; -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o User=user -o ConnectTimeout=10 192.168.33.100 /bin/sh -c &#39;mkdir -p $HOME/.</description>
    </item>
    
    <item>
      <title>Ansibleを踏み台サーバ越しに実行する</title>
      <link>https://blog.mosuke.tech/entry/2015/09/25/232751/</link>
      <pubDate>Fri, 25 Sep 2015 23:27:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/09/25/232751/</guid>
      <description>タイトルの通りで、なにも特別なことはない内容。
そして、9月も終わりなのに今月はひとつも記事を書いていなかった。
KVMを使って仮想のゲストサーバを立てたが、
ゲストサーバはホストサーバと通信する用の（外に出る場合にはNAT通信で）IPアドレスしか持っていない状況で、
Ansibleの実行対象としたかったのが背景。
ホストサーバにAnsibleをいれるわけにもいかず、ホストサーバを踏み台にして、
Ansibleを打ちたかったというもの。

 SSHの設定ファイルを作る &#34;Ansibleで&#34; と書いたが要はSSHです。
まずはSSHで踏み台サーバを経由してAnsible実行対象サーバへ接続できるように準備しました。
これはいわゆる「多段SSH」というやつで、以前にもブログに書いたので復習です。
【VPS1台でインフラ勉強】多段SSH設定（おまけ） - Goldstine研究所
一般的には~/.ssh/configにこういった設定は書いたりもしますが、
Ansible実行の場合、端末に依存したくなかったので、
Ansibleレポジトリに別途ファイルを作ることにした。
## sshconfigという名前のファイルにした Host ansible-target HostName 192.168.33.10 User xxxxx ProxyCommand ssh -W %h:%p yyyyy@hostserver  上記のファイルを使って多段SSHできることを確認します。
$ ssh -F sshconfig ansible-target  Ansible実行時にSSH設定ファイルを利用する ここまで来たらとても簡単で、
ansible.cfgに下記を追記し、ansible実行時に上記のsshconfigを読み込まれるようにしました。
ansible.cfg
[ssh_connection] ssh_args = -F sshconfig</description>
    </item>
    
    <item>
      <title>Ansibleで最新のMySQLをインストールする際にハマったこと。MySQL-shared-compatのこと。</title>
      <link>https://blog.mosuke.tech/entry/2015/04/15/171127/</link>
      <pubDate>Wed, 15 Apr 2015 17:11:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/04/15/171127/</guid>
      <description>CentOS 6.5環境でAnsibleを使って最新のMySQLのセットアップをしようと思った際にハマったことをまとめた。
本質的にはAnsibleというよりLinux RPMパッケージのはなし。
ついでに、しょっぼいgithubを公開しました。
(1) 本記事を書くに至った経緯  Ansibleでmysqlを使ったサーバを構築(CentOS6.5)することになった。   MySQLのバージョンは5.6を採用した。    MySQLの公式rpmをダウンロードしインストールした。  インストールしたもの：MySQL-client, MySQL-devel, MySQL-server, MySQL-shared    MySQL-sharedをインストールする際にデフォルトのmysql-libsと競合  mysql-libsをアンインストールし再インストール AnsibleでMySQLの操作をするにはMySQL-pythonが必要なのでインストール  MySQL-pythonをインストールするにはさっきアンインストールしたmysql-libsが必要…(困った)  MySQL-shared-compatの存在に気づく 備忘録に書いておくか…  (2) MySQL-shared-compatの存在 mysql-libsは多くのパッケージの依存となっており、公式のMySQL5.6をインストールすることで、
他のパッケージがいれられない状況となっていた。
そんな状況を解決するためにMySQL-shared-compatというパッケージが用意されていた。
MySQL-shared-compatは「過去のMySQLバージョン向けの共有クライアントライブラリが納められているもの」だ。
詳細は下記参照をおすすめ。
MySQL-5.5.6から仕様が変わった「MySQL-shared-compat」の中身を徹底解剖 - Y-Ken Studio
ちなみに&#34;compat&#34;という単語がよく使われるが&#34;compatibility&#34;の略で「互換性」とかそういう意味。
(3) Githubで公開しました 内容は今のところ死ぬほど薄いのだが、MySQLをインストールするansibleを公開しました。 mosuke5/mysql-ansible · GitHub
内容はあれだが、特徴としては、インターネット上からRPMをダウンロードしてインストールする際に、
Ansibleでも「ダウンロード」→「インストール」の流れを踏む人が多いが、以下のようにするとシンプルになる。
varsでインストールしたいrpmやその取得先を記述しておいて、task側ではyumでnameにvarsで定義した変数を読むだけでできる。
role/mysql/vars/main.yml
mysql_url: http://ftp.jaist.ac.jp/pub/mysql/Downloads/MySQL-5.6 mysql_ver: &amp;quot;5.6.24-1&amp;quot; mysql_rpms: - MySQL-client-{{ mysql_ver }}.el6.x86_64.rpm - MySQL-shared-compat-{{ mysql_ver }}.el6.x86_64.rpm - MySQL-shared-{{ mysql_ver }}.</description>
    </item>
    
    <item>
      <title>Ansible、コマンド実行結果を&amp;quot;ok&amp;quot;にする（冪等性を保つ方法）</title>
      <link>https://blog.mosuke.tech/entry/2015/02/02/201008/</link>
      <pubDate>Mon, 02 Feb 2015 20:10:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2015/02/02/201008/</guid>
      <description>Ansibleでソースコードインストールする際とか
すでにインストールされているかのチェックなどで、
シェルコマンドを実行してその結果で判断したい時がある。
ぼくがよくやる例では以下とか。
- name: check httpd installed command: which httpd ignore_errors: true  なんですが...
こうやってしまうと、仮に既にインストールされていて、正常なときでも&#34;changed&#34;と表示されてしまう。
これでは、本当にchangedなものなのか、わからなくなってくる。
これを解決するのにchaged_whenを使うといい。
- name: check httpd installed command: which httpd ignore_errors: true changed_when: false  こうするとコマンドが成功した際には&#34;ok&#34;が表示される。
これで、何も変化がないときにはokとskippingしかでないから、
誰がみても結果がわかりやすいですね！
秘伝のタレ回避！</description>
    </item>
    
    <item>
      <title>Ansible, sudoパスワード要求を忘れただけでめんどくなる</title>
      <link>https://blog.mosuke.tech/entry/2014/11/28/001748/</link>
      <pubDate>Fri, 28 Nov 2014 00:17:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2014/11/28/001748/</guid>
      <description>AnsibleをVagrant上でずっと使ってて、Playbookも完成したし本番サーバへ&amp;hellip;
と思ったところである初歩的な罠にハマった。
本番環境へPalybook実行！！
$ ansible-playbook playbook.yml -i hosts  あれ、GATHERING FACTSで10分以上も待たされた&amp;hellip;
しかも、エラー出た&amp;hellip;
GATHERING FACTS failed to parse [ sudo via ansible, key= ..... ]  sudoできていない&amp;hellip;？
playbook内のsudo: yesを外して実行。
GATHERING FACTSは通過。
しかし、当たり前だがsudo で実行すべき部分で失敗&amp;hellip;
とても単純なことに気づいた&amp;hellip;
・Vagrant環境ではsudoのパスワードを要求されない
・本番環境はsudoのパスワードを要求されること
・sudoのパスワードを入力するようにしていなかったこと
というわけで-Kをつけて実行
$ ansible-playbook playbook.yml -i hosts -K  うまくいった&amp;hellip;
完全なる私のミスなんだが、ただ-Kオプションを忘れるだけで、一回の実行に10分ほども待たされるのは…。
しかもGATHERING FACTSで止まっているときはCtl+Cで中断も聞かなかった。
要注意ですね。。。
ちなみに、こんな方法で解決もできる。
sudoのパスワードを聞かれなくして対応。
# visudo user_name ALL=(ALL) NOPASSWD: ALL</description>
    </item>
    
    <item>
      <title>Ansible、コマンドでワイルドカードを使うときの注意</title>
      <link>https://blog.mosuke.tech/entry/2014/11/18/225542/</link>
      <pubDate>Tue, 18 Nov 2014 22:55:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2014/11/18/225542/</guid>
      <description>AnsibleのPlaybookを書いていると、ワイルドカードを含んだコマンドを実行したい時がある。
そんなときあるところでハマった。
Apacheをソースインストールして、パスを/usr/sbinにリンクを貼ろうとして以下を実行した。
- command: ln -s /usr/local/httpd/bin/* /usr/sbin  /usr/sbin内に「*」というリンクが貼られてしまった。
* -&amp;gt; /usr/local/httpd/bin  どうやらcommandモジュールはワイルドカードに対応していないよう。
ワイルドカードを使いたいときはshellモジュールを利用すると良い。
- shell: ln -s /usr/local/httpd/bin/* /usr/sbin  また、*というリンクを消すときは要注意（笑）
$ rm ./*  とやってしまうとあたりまえだがやばいので
$ rm ./¥*  こうですね…</description>
    </item>
    
    <item>
      <title>Ansible、ソースインストールする際のPalybookの書き方</title>
      <link>https://blog.mosuke.tech/entry/2014/11/16/153223/</link>
      <pubDate>Sun, 16 Nov 2014 15:32:00 +0900</pubDate>
      
      <guid>https://blog.mosuke.tech/entry/2014/11/16/153223/</guid>
      <description>最近、Ansibleを使い始めたのだが、yumやapt-getでインストールできるものはいいけど、
どうしてもソースインストールが必要な場合がある。
ソースインストールを行う際のPlaybookの書き方と注意点をまとめた。
まず、あたりまえだが、ソースインストールを行うには以下のフローを踏まなければいけな。
1. ソースファイルの取得(tarで固められていると仮定)
2. tarファイルの解凍
3. 解答してできたディレクトリへ移動
4. configure
5. make
6. make install
また、Ansibleでは何回もPlaybookを実行していくため、
すでにインストールされている場合は、インストールをスキップする必要がある。
yumやapt-getで管理されていれば上記を心配することはないのだが、やはりソースインストールだとこの壁がある。
※パッケージ化しろよ！というツッコミは禁止
今回は例として、ubuntu13にemacsをソースインストールするのを例としてみた。
環境 【Ansible実行側】
さくらVPSの1G
OS: Centos 7
IPアドレス:192.168.33.1
【設定対象側】
上記さくらVPS上にたてたVagrantの仮想サーバ
OS: Ubuntu 13.10
IPアドレス:192.168.33.100
 Playbook 以下playbookの例。
--- - hosts: 192.168.33.100 user: vagrant sudo: yes vars: src_dir: /usr/local/src emacs_ver: emacs-23.4 tasks: ## emacsのソースファイルを取得済みか確認 - name: check exist emacs source file command: ls -l {{src_dir}}/{{emacs_ver}}.tar.gz ignore_errors: True register: result1 ## emacsのソースファイル取得。ただし、すでに取得済みならスキップ - name: get emacs source file command: chdir={{src_dir}} wget http://mirror.</description>
    </item>
    
  </channel>
</rss>